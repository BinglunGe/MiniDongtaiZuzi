//作者: 葛炳仑
const 界面脚本标识符 = [" ", "\t", "\n", "\r"];
const 界面脚本区块标识符 = {
	类型: ["文本", "字典", "延迟", "向量", "注释", "数字"],
	开始: ["<", "[", "{", "(", "/*"],
	结束: [">", "]", "}", ")", "*/"]
};
const 转义符 = {
	符号: "^",
	转义表: {
		"^": "^",
		"N": "\n\r",
		"T": "\t"
	}
};
const 当前进行中界面脚本任务 = [];
const 数组缓冲 = ArrayBuffer;
const 位宽 = 16;
const 字节比特数 = 8;
const 无符号当前位宽位整型 = ({
	8: 无符号八位整型,
	16: 无符号十六位整型,
	32: 无符号三十二位整型
	/*,
		64: Uint64Array*/
})[位宽];
const 内存大小 = (2).的几次方(位宽);
const 全局内存 = new 数组缓冲(内存大小);
let 数字精度 = 14;
let 高精度演算 = 假;
let 小数点字符 = "." /*","*/ ;
let 最大循环数 = 255;
let 基本库 = 同步获取文件("DTA/UILIB/INIT.UIT");

function 处理界面脚本(脚本源码) {
	let 脚本 = new 解释界面脚本(脚本源码);
	脚本.界面脚本运行();
	return 脚本.获取输出() + 打印栈(脚本.脚本);
}

class 界面脚本对象 {
	constructor() {
		this.类型 = "错误类型!!";
		this.内容 = "错误内容!!";
	}
	排错打印() {
		if (排错中) {
			打印(`类型是“${this.类型}”，内容是“${this.内容}”；`);
		}
	}
	处理运算符(内容, 类型) {
		if (内容.是不是数()) {
			//打印(内容);
			//let 结果 = 
			return ["数字",
				(
					(
						内容 => {
							if (不(内容.的第几个字(0) === "f")) {
								let 负 = 假;
								if (内容.的第几个字(0) === "-") {
									内容 = 内容.子字符串(1);
									负 = 真;
								}
								return ("0" + 内容).转为数() * (负 ? -1 : 1);
							} else {
								return new 数字(内容.子字符串(1));
							}
						}
					)(内容)
				)
			];
			//打印(结果);
			//return 结果;
		} else {
			return [类型, 内容];
		}
	}
	处理字典() {
		let 结果 = {};
		for (
			let i = 0; i < (
				是数组(this.内容) ? this.内容.的长度() : 对象的长度(this.内容)
			); i++
		) {
			//for (let i in this.内容) {
			打印(i)
			if (typeof this.内容[i].内容 === 类型的中文.字符串) {
				if (this.内容[i].内容.的第几个字(0) === "\\") {
					结果[this.内容[i].内容.子字符串(1)] = this.内容[++i];
				}
			}
		}
		this.内容 = 结果;
	}
	设置类型为(对象类型) {
		//请在设置内容后设置类型
		if (对象类型.存在(界面脚本区块标识符.类型) !== -1) {
			if (对象类型 === "字典") {
				if (是数组(this.内容)) {
					this.处理字典();
				}
				打印("遇到了字典", this.内容);
			}
			this.类型 = 对象类型;
			return this;
		} else if (对象类型 === "运算符") {
			let 临时运算符处理结果 = this.处理运算符(this.内容, "运算符");
			this.类型 = 临时运算符处理结果[0];
			this.内容 = 临时运算符处理结果[1];
			//this.排错打印();
			return this;
		} else {
			警告(`字符串“${this.内容}”是错误的界面脚本类型“${对象类型}”。`);
			return this;
		}
	}
	设置内容为(内容) {
		this.内容 = 内容;
		return this;
	}
}
class 脚本栈 {
	constructor() {
		this.栈 = []; //new Array();
	}
	PICK() {
		let 复制项索引 = this.栈.取顶().内容;
		//打印([栈,栈.的长度() , 复制项索引, 栈[栈.的长度() - 复制项索引]])
		this.栈.推入(this.栈[this.栈.的长度() - 复制项索引 - 1]);
	}

	ROLL() {
		//debugger
		let 移动项索引 = this.栈.取顶().内容;
		let 栈长 = this.栈.的长度();
		let 被移动数 = this.栈[栈长 - 移动项索引 - 1];
		let 栈 = (
			this.栈.切片(0, 栈长 - 移动项索引 - 1)
			.平坦推入(this.栈.切片(栈长 - 移动项索引))
			.平坦推入(被移动数)
		);
		this.栈 = 栈;
		//打印(">>", 栈, 栈长, 移动项索引, [栈.切片(0, 栈长 - 移动项索引 - 1)
		//, (栈.切片(栈长 - 移动项索引)), (被移动数)])
	}
	检测是否空() {
		if (this.的长度() === 0) {
			警告("栈已空!!");
		}
	}
	真取顶() {
		this.检测是否空();
		return this.栈.取顶();
	}
	真获顶() {
		this.检测是否空();
		return this.栈[this.栈.的长度() - 1];
	}
	真推入(内容) {
		this.栈.推入(内容);
		return this;
	}
	获顶() {
		this.检测是否空();
		return this.真获顶().内容;
	}
	取顶() {
		this.检测是否空();
		return this.真取顶().内容;
	}
	的长度() {
		return this.栈.的长度();
	}
	切片(开始, 结尾) {
		return this.栈.切片(开始, 结尾);
	}
	推入(内容) {
		//打印(内容);
		this.真推入(
			new 界面脚本对象()
			.设置内容为(含有(内容, "内容") ? 内容.内容 : 内容)
			.设置类型为(this.判断无类型对象类型(内容))
		);
		return this;
	}
	判断无类型对象类型(对象) {
		//打印(对象)
		return (
			含有(对象, "类型") ?
			对象.类型 :
			({
				number: "数字",
				object: "延迟",
				string: "运算符"
			} [typeof 对象])
		);
	}
}
class 运算符 {
	constructor(栈, 返回栈) {
		this.运算符表 = {};
		this.对象表 = {};
		this.栈 = 栈;
		this.返回栈 = 返回栈;
		//打印(this.栈.栈)
	}
	注册(运算符名, 函数) {
		this.运算符表[运算符名] = 函数;
	}
	运行脚本(脚本, 完整) {
		this.运行更多(脚本, 不(完整));
	}
	运行自定义(运算符名) {
		/*console.log(this);*/
		//打印("运算符名:", 运算符名);
		//打印("内容:", this.对象表[运算符名]);
		this.运行更多(深拷贝(this.对象表[运算符名]), 真);
	}
	标帜转JS(标帜) {
		if (标帜 === -1) {
			return 假;
		} else {
			return 真;
		}
	}
	载入基本运算符() {
		let 此 = this;
		let 运算表 = [
			[
				"ADD",
				function (栈, 返回栈) {
					let 加数乙 = 栈.取顶();
					let 加数甲 = 栈.取顶();
					栈.推入(加数甲 + 加数乙);
				}
			],
			[
				"SUB",
				function (栈, 返回栈) {
					let 减数 = 栈.取顶();
					let 被减数 = 栈.取顶();
					栈.推入(被减数 - 减数);
				}
			],
			[
				"MUL",
				function (栈, 返回栈) {
					let 乘数乙 = 栈.取顶();
					let 乘数甲 = 栈.取顶();
					栈.推入(乘数甲 * 乘数乙);
				}
			],
			[
				"DIV",
				function (栈, 返回栈) {
					let 除数 = 栈.取顶();
					let 被除数 = 栈.取顶();
					栈.推入(被除数 / 除数);
				}
			],
			[
				"DEPTH",
				function (栈, 返回栈) {
					栈.推入(栈.的长度());
				}
			],
			[
				"NEGATE",
				function (栈, 返回栈) {
					栈.推入(-1 * 栈.取顶());
				}
			],
			[
				"ABS",
				function (栈, 返回栈) {
					let 栈顶 = 栈.取顶();
					栈.推入(栈顶 >= 0 ? 栈顶 : -1 * 栈顶);
				}
			],
			[
				"MOD",
				function (栈, 返回栈) {
					let 除数 = 栈.取顶();
					let 被除数 = 栈.取顶();
					//打印(被除数, "%", 除数, 被除数 % 除数)
					栈.推入(被除数 % 除数);
				}
			],
			[
				"/MOD",
				function (栈, 返回栈) {
					let 被除数 = 栈.取顶();
					let 除数 = 栈.取顶();
					栈.推入(被除数 % 除数);
					栈.推入(被除数 / 除数);
				}
			],
			[
				"MAX",
				function (栈, 返回栈) {
					let 数甲 = 栈.取顶();
					let 数乙 = 栈.取顶();
					栈.推入(数甲 > 数乙 ? 数甲 : 数乙);
				}
			],
			[
				"MIN",
				function (栈, 返回栈) {
					let 数甲 = 栈.取顶();
					let 数乙 = 栈.取顶();
					栈.推入(数甲 < 数乙 ? 数甲 : 数乙);
				}
			],
			[
				"DUP",
				function (栈, 返回栈) {
					let 数 = 栈.取顶();
					栈.推入(数);
					栈.推入(数);
				}
			],
			[
				".S",
				function (栈, 返回栈) {
					//打印("当前栈: ", 深拷贝(栈));
					此.打印(
						`
							<div class="uitStackSnapshot">
								<table border="1">
									<tr>
										<td>
											参数栈
										</td>
									</tr>
									<tr>
										<td>
											${
												打印栈(栈)
											}
										</td>
									</tr>
									<tr>
										<td>
											返回栈
										</td>
									</tr>
									<tr>
										<td>
											${
												打印栈(返回栈)
											}
										</td>
									</tr>
								</table>
							</div>
						`
					);
				}
			],
			[
				".",
				function (栈, 返回栈) {
					此.打印(栈.取顶());
				}
			],
			[
				"DROP",
				function (栈, 返回栈) {
					栈.取顶();
				}
			],
			[
				"PICK",
				function (栈, 返回栈) {
					栈.PICK();
					/*let 复制项索引 = 栈.取顶();
					//打印([栈,栈.的长度() , 
					复制项索引, 栈[栈.的长度() - 复制项索引]])
					栈.推入(栈[栈.的长度() - 复制项索引 - 1]);*/
				}
			],
			[
				"ROLL",
				function (栈, 返回栈) {
					栈.ROLL();
					/*let 移动项索引 = 栈.取顶();
					let 栈长 = 栈.的长度();
					let 被移动数 = 栈[栈长 - 移动项索引 - 1];
					栈 = (
						栈.切片(0, 栈长 - 移动项索引 - 1)
						.平坦推入(栈.切片(栈长 - 移动项索引))
						.平坦推入(被移动数)
					);
					此.栈 = 栈;*/
					//打印(">>", 栈, 栈长, 移动项索引, [栈.切片(0, 栈长 -
					// 移动项索引 - 1), (栈.切片(栈长 - 移动项索引)), (
					//被移动数)])
				}
			],
			[
				":",
				function (栈, 返回栈) {
					let 运算符名 = 栈.取顶();
					let 此对象 = 栈.取顶();
					if (typeof 此对象 === 类型的中文.对象) {
						此.注册(
							运算符名,
							function () {
								此.运行自定义(运算符名);
							}
						);
						此.对象表[运算符名] = 此对象;
					} else {
						此.注册(
							运算符名,
							function () {
								此.运行脚本(此对象, 真);
							}
						);
					}

				}
			],
			[
				"EQUAL?",
				function (栈, 返回栈) {
					栈.推入(栈.取顶() == 栈.取顶() ? 0 : -1);
				}
			],
			[
				"IF?THEN,ELSE",
				function (栈, 返回栈) {
					//打印(栈);
					let 则运行 = 栈.取顶();
					let 就运行 = 栈.取顶();
					let 标帜 = 此.标帜转JS(栈.取顶());
					//打印("若则", [则运行, 就运行, 标帜]);
					if (标帜) {
						此.运行脚本(就运行);
					} else {
						此.运行脚本(则运行);
					}
				}
			],
			[
				">R",
				function (栈, 返回栈) {
					返回栈.推入(栈.取顶());
				}
			],
			[
				"R>",
				function (栈, 返回栈) {
					栈.推入(返回栈.取顶());
				}
			],
			[
				"R@",
				function (栈, 返回栈) {
					栈.推入(返回栈.获顶());
				}
			],
			[
				"I",
				function (栈, 返回栈) {

				}
			],
			[
				"UNTIL?LOOP",
				function (栈, 返回栈) {
					/*
						'START >R						<-	将起始数推到返回栈
															栈顶
						{I 'TO GREATER? R> 'STEP + >R}	<-	延迟变量, 运行后在
															栈顶放入结束标识符:
																真: 结束;
																假: 继续;
						{'...} UNTIL?LOOP 				<-	真正执行的代码块
					*/
					//debugger
					let 执行代码块 = 栈.取顶();
					let 是否结束代码块 = 栈.取顶();
					打印("循环测试: ", 是否结束代码块, 执行代码块);
					let 循环次数 = 0;
					//此.运行脚本(是否结束代码块);
					while (
						此.运行脚本(是否结束代码块) ||
						逻辑非(此.标帜转JS(栈.取顶()))
					) {
						此.运行脚本(执行代码块);
						if (循环次数++ >= 最大循环数) {
							break;
						}
					}
				}
			],
			[
				"CON",
				function (栈, 返回栈) {
					//打印("要连接的: ", 栈.栈.高级切片("-2:"));
					//栈.推入((栈.取顶()).平坦推入(栈.取顶()));
					let 元素乙 = 栈.真取顶();
					let 元素甲 = 栈.真取顶();
					//警告(元素甲, 元素乙)
					//栈.推入([元素甲].平坦推入([元素乙]));
					栈.真推入(
						new 界面脚本对象()
						.设置内容为(
							//元素甲加元素乙
							(
								(元素甲, 元素乙) => {
									//debugger
									if (元素甲.类型 !== "延迟") {
										if (元素乙.类型 !== "延迟") {
											//打印(1);
											//元素甲和元素乙都不是延迟
											return [元素甲, 元素乙];
										} else {
											//元素甲不是延迟, 元素乙是延迟
											//打印(2);
											元素乙.内容.在前推入(元素甲);
											return 元素乙;
										}
									} else if (元素乙.类型 !== "延迟") {
										//元素甲是延迟, 元素乙不是延迟
										//打印(3);
										元素甲.内容.推入(元素乙);
										//打印(元素乙, "推入后: ", 元素甲);
										return 元素甲;
									} else {
										//元素甲和元素乙都是延迟
										//打印(4, 元素甲.内容, 元素乙.内容);
										元素甲.内容 = 元素甲.内容.连接(
											元素乙.内容
										);
										return 元素甲;
									}
								}
							)(元素甲, 元素乙)
							.内容
						)
						.设置类型为("延迟")
					);
					//打印("连接后的: ", 栈.栈[栈.栈.的长度() - 1]);
				}
			],
			[
				"GREATER?",
				function (栈, 返回栈) {
					let 元素乙 = 栈.取顶();
					let 元素甲 = 栈.取顶();
					栈.推入(元素甲 > 元素乙 ? 0 : -1);
				}
			],
			[
				"LESS?",
				function (栈, 返回栈) {
					let 元素乙 = 栈.取顶();
					let 元素甲 = 栈.取顶();
					栈.推入(元素甲 < 元素乙 ? 0 : -1);
				}
			],
			[
				"IMPORT",
				function (栈, 返回栈) {
					let 库名 = 栈.取顶();
					此.运行脚本(
						此.界面脚本切片(同步获取文件(`DTA/UILIB/${库名}.UIT`))
					);
				}
			],
			[
				"GET",
				function (栈, 返回栈) {
					let 键 = 栈.取顶();
					let 字典 = 栈.取顶();
					栈.推入(字典[键]);
				}
			]
		];
		for (let i = 0; i < 运算表.的长度(); i++) {
			if (运算表[i][0]) {
				this.注册(运算表[i][0], 运算表[i][1]);
			}
		}
	}
	运算(运算符名) {
		if (含有(this.运算符表, 运算符名)) {
			try {
				this.运算符表[运算符名](this.栈, this.返回栈);
			} catch (e) {
				打印(
					"在运算", 运算符名, "时出错!!\n错误信息: ", e,
					"此时栈内容: ", this.栈.内容
				);
			}

		} else {
			打印("运算符未定义>", 运算符名);
		}
		return;
	}
}
class 解释界面脚本 extends 运算符 {
	constructor(界面脚本) {
		super(new 脚本栈(), new 脚本栈());
		this.脚本 = this.界面脚本切片(基本库 + 界面脚本);
		/*this.栈 = [];
		this.返回栈 = [];
		this.运算符 = new 运算符(this.栈, this.返回栈);
		this.运算符.载入基本运算符();*/
		this.输出 = [];
		this.载入基本运算符();
	}
	获取输出() {
		return this.输出.加入(" ");
	}
	打印(内容) {
		this.输出.推入(内容);
		//打印("脚本:", 内容);
	}
	_打印脚本(内容) {
		let 输出 = new 字符串缓冲();
		for (let i = 0; i < 内容.的长度(); i++) {
			if (含有(内容[i], "内容")) {
				if (内容[i].类型 === "文本") {
					输出.添加(" <").添加(内容[i].内容).添加("> ");
				} else if (内容[i].类型 === "延迟") {
					输出.添加(" {").添加(内容[i].内容).添加("} ");
				} else {
					输出.添加(内容[i].内容).添加(" ");
				}
			} else if (内容[i] instanceof 类型的中文.数组) {
				输出.添加(" ").添加(this._打印脚本(内容[i])).添加(" ");
			} else {
				输出.添加(内容[i]).添加(" ");
			}
		}
		return 输出.转为字符串();
	}
	打印脚本(内容) {
		打印("脚本: ", this._打印脚本(内容));
	}
	运行更多(界面脚本, 直接运行) {
		let 脚本;
		if (!直接运行) {
			脚本 = this.界面脚本切片(界面脚本);
		} else {
			脚本 = 界面脚本;
		}
		this.界面脚本运行(脚本);
	}
	界面脚本运行(脚本) {
		//debugger;
		脚本 = 脚本 || this.脚本;
		try {
			for (let i = 0; i < 脚本.的长度(); i++) {
				this._界面脚本运行(脚本, i);
			}
		} catch (e) {
			打印(脚本, e);
		}

		//console.log(this.栈);
		//打印(this.运算符表);
		return;
	}
	_界面脚本运行(脚本, i) {
		let 当前内容 = 脚本[i];
		//打印(当前内容);
		if (当前内容.类型 !== "运算符") {
			this.栈.推入(当前内容);
		} else {
			this.运算(当前内容.内容);
		}
	}
	界面脚本切片(界面脚本) {
		界面脚本 += " ";
		let 结果 = [];
		let 当前词 = new 字符串缓冲();
		let 在区块内 = 假;
		let 在无界定符运算符内 = 假;
		let 当前字;
		let 区块类型 = "";
		let 区块结束符 = "";
		let 区块开始符 = "";
		let 区块开始符已有数量 = 0;
		let 多于单字符界面脚本区块标识符数组
		let 多于单字符字符串筛子, 取数组内成员的第几个字;
		//debugger
		for (let i = 0; i < 界面脚本.的长度(); i++) {
			当前字 = 界面脚本.的第几个字(i);
			if (
				当前字 === 转义符.符号 ||
				(
					当前字.存在(
						(
							多于单字符界面脚本区块标识符数组 = (
								界面脚本区块标识符.开始.筛选(
									(
										多于单字符字符串筛子 = (
											(字符串) => {
												if (字符串.的长度() >= 2) {
													return 真;
												}
												return 假;
											}
										)
									)
								).连接(
									界面脚本区块标识符
									.结束
									.筛选(多于单字符字符串筛子)
								)
							)
						).遍历(
							(
								取数组内成员的第几个字 = (
									(取第几个字) => {
										return (
											(字符串) => {
												return (
													字符串
													.的第几个字(
														取第几个字
													)
												)
											}
										)
									}
								)
							)(0)
						)
					) !== -1
				)
			) {
				//debugger
				if (当前字 !== 转义符.符号) {
					if (
						(
							界面脚本
							.的第几个字(i + 1)
							.存在(
								多于单字符界面脚本区块标识符数组
								.遍历(取数组内成员的第几个字(1))
							)
						) !== -1
					) {
						当前字 += 界面脚本.的第几个字(++i);
					}
				} else {
					当前字 += 界面脚本.的第几个字(++i);
				}
			}
			if (不(在区块内)) {
				//如果现在还没被扩号扩起来的话：
				if (
					(区块类型 = (当前字.存在(界面脚本区块标识符.开始))) !== -1
				) {
					//如果这个字就是左扩号：
					在区块内 = 真;
					区块开始符 = 当前字;
					区块开始符已有数量++;
					区块结束符 = 界面脚本区块标识符.结束[区块类型];
					区块类型 = 界面脚本区块标识符.类型[区块类型];
					continue;
				} else {
					//如果现在这个字不是左扩号而且在扩号外面：
					//	也不可能是右扩号嘛，毕竟右扩号不会单独出来。
					if (当前字.存在(界面脚本标识符) !== -1) {
						//如果当前字符为空：
						if (在无界定符运算符内) {
							//如果正在操作符里头：
							//	那就是说明操作符结束了。
							结果.推入(
								new 界面脚本对象()
								.设置内容为(当前词.转为字符串())
								.设置类型为("运算符")
							);
							当前词.清除();
							在无界定符运算符内 = 假;
						}
						continue;
					} else {
						//如果不为空：
						if (在无界定符运算符内) {
							//如果正在操作符里头：
							当前词.添加(当前字);
						} else {
							在无界定符运算符内 = 真;
							当前词.添加(当前字);
						}
					}
				}
			} else {
				//如果已经被扩号扩起来了：
				if (当前字 === 区块开始符) {
					//如果有嵌套的话：
					区块开始符已有数量++;
					当前词.添加(当前字);
				} else if (当前字 === 区块结束符) {
					//如果当前扩号结束了：
					区块开始符已有数量--;
					if (区块开始符已有数量 === 0) {
						//如果嵌套已经消完了：
						if (区块类型 !== "注释") {
							结果.推入(
								new 界面脚本对象()
								.设置内容为(
									(
										区块类型 === "字典" ||
										区块类型 === "向量" ||
										区块类型 === "延迟"
									) ?
									this.界面脚本切片(当前词.转为字符串()) :
									当前词.转为字符串()
								)
								.设置类型为(区块类型)
							);
						}
						当前词.清除();
						在区块内 = 假;
					} else {
						当前词.添加(当前字);
					}
				} else {
					当前词.添加(当前字);
				}
			}
		}
		//console.log(结果)
		return 结果;
	}
}
class 已使用内存区间 {
	constructor(起始地址, 结束地址) {
		this.起始地址 = 起始地址 || 0xf000;
		this.结束地址 = 结束地址 || 0xffff;
		this.内存表内容 = new 无符号当前位宽位整型(
			全局内存,
			this.起始地址,
			~~((this.结束地址 - this.起始地址) / 3));
		this.内存表类 = function (内存表内容, 起始地址, 结束地址) {
			this.内存表内容 = 内存表内容;
			this.起始地址 = 起始地址 || 0xf000;
			this.结束地址 = 结束地址 || 0xffff;
			this.内存表当前位置索引 = 0;
			this.内存表当前内存值索引 = 0;
		}
		this.内存表类.prototype.初始化 = function () {
			this.内存表当前位置索引 = 0;
		}
		this.内存表类.prototype.下一个 = function () {
			if (
				this.内存表当前位置索引 >= this.结束地址 - 3
				//(位宽 / 字节比特数 * 3)
			) {
				this.内存表当前位置索引 = 0;
			}
			let 结果 = [
				//起始地址, 结束地址, 是否被占用
				this.内存表内容[this.内存表当前位置索引],
				this.内存表内容[1 + this.内存表当前位置索引],
				this.内存表内容[2 + this.内存表当前位置索引],
			];
			this.内存表当前位置索引 += 3 //位宽 / 字节比特数 * 3; // /8*2
			if (没(结果[1])) {
				return [this.结束地址, this.结束地址];
			} else {
				return 结果;
			}
		}
		this.内存表类.prototype.写入 = function (起始地址, 数据长度) {
			this.内存表当前位置索引 -= 3
			this.内存表内容[this.内存表当前位置索引] = 起始地址;
			this.内存表内容[1 + this.内存表当前位置索引] =
				起始地址 + 数据长度;
			this.内存表内容[2 + this.内存表当前位置索引] = this.结束地址;
			//this.内存表当前位置索引 += 3
			//位宽 / 字节比特数 * 3; // /8*2
			this.内存表当前内存值索引 += 数据长度;
			return [
				this.内存表内容[this.内存表当前位置索引],
				this.内存表内容[1 + this.内存表当前位置索引],
				this.内存表当前位置索引
			];
		}
		this.内存表类.prototype.释放 = function (被释放内存表内位置索引) {
			打印(被释放内存表内位置索引);
			this.内存表内容[2 + 被释放内存表内位置索引] = 0;
			return;
		}
		this.内存表 = new this.内存表类(
			this.内存表内容, this.起始地址, this.结束地址
		);
	}
	搜索并分配可用空间(数据长度) {
		//debugger
		this.内存表.初始化();
		let 内存搜索结果 = [];
		for (
			var i = 0; i < this.内存表.内存表内容.length / 3; i++
		) {
			内存搜索结果 = this.内存表.下一个();
			//打印(内存搜索结果)
			if (
				(
					内存搜索结果[0] === this.结束地址 ||
					内存搜索结果[1] === this.结束地址
				) && 内存搜索结果[2] !== this.结束地址
			) {
				打印(
					"新增",
					this.内存表.内存表当前内存值索引,
					this.内存表.内存表当前内存值索引 + 数据长度
				);
				return this.内存表.写入(
					this.内存表.内存表当前内存值索引,
					数据长度
				);
			} else if (内存搜索结果[2] === this.结束地址) {
				//打印("已使用", 内存搜索结果);
				continue;
			} else if (内存搜索结果[1] - 内存搜索结果[0] < 数据长度) {
				打印("不够", 内存搜索结果);
				continue;
			} else {
				打印("采用");
				/*return this.内存表.写入(
					内存搜索结果[0],
					数据长度
				);*/
				内存搜索结果[2] = (this.内存表.内存表当前位置索引);
				return 内存搜索结果;
			}
		}
		return 假;
	}
}

const 已使用内存 = new 已使用内存区间();

class 内存对象 {
	constructor() {
		this.起始 = 0;
		this.结束 = 0;
		this.内容 = null;
		this.表内 = 0;
	}
	分配(数据长度, 数据类型) {
		数据类型 = 数据类型 || 无符号当前位宽位整型;
		let 临时内存结果 = 已使用内存.搜索并分配可用空间(数据长度);
		this.起始 = 临时内存结果[0];
		this.结束 = 临时内存结果[1];
		this.表内 = 临时内存结果[2];
		this.内容 = new 数据类型(
			全局内存,
			this.起始,
			数据长度);
	}
	释放() {
		已使用内存.内存表.释放(this.表内);
	}
}

class 数字 {
	constructor(数字字符串) {
		this.数字 = new 内存对象();
		this.数字.分配(2);
		this.以字符串赋予(数字字符串);
		打印(
			数字字符串, eval(
				this.转为字符串()
			), this.数字.内容, this.转为字符串()
		);
	}
	导入浮点数(是负数, 数, 十进制负幂数) {
		this.数字.内容[0] = 数;
		this.数字.内容[1] = 是负数 ? (
			(2).的几次方(位宽) - 十进制负幂数 //负数
		) : (
			十进制负幂数
		);
	}
	以数赋予(数) {
		this.以字符串赋予(数.转为字符串());
		/*this.导入浮点数(
			数<0,
			数.转为字符串.替换(".", "").转为数(),
			十进制负幂数
		);*/
	}
	转为数() {
		return 解释(this.转为字符串());
	}
	以字符串赋予(数字字符串) {
		if (数字字符串.的长度() > 5) {
			数字字符串 = 数字字符串.子字符串(
				0,
				(
					数字字符串.字符的索引(小数点字符) < 5 ? (
						6
					) : (
						5
					)
				)
			);
		}
		let 小数点位置 = 数字字符串.字符的索引(小数点字符);
		let 长度 = 数字字符串.的长度();
		let 十进制负幂数;
		let 是负数 = 数字字符串.的第几个字(0) === "-";
		if (小数点位置 === -1) {
			//不是小数
			十进制负幂数 = 0;
			//打印(数字字符串);
		} else {
			十进制负幂数 = 长度 - 小数点位置 - 1;
		}
		if (是负数) {
			数字字符串 = 数字字符串.子字符串(1);
		}
		this.导入浮点数(
			是负数,
			数字字符串.替换(".", "").转为数(),
			十进制负幂数
		);
	}
	是否为负数并取其十进制负幂数() {
		return [
			this.数字.内容[1] >= (2).的几次方(位宽) / 2,
			this.数字.内容[1] >= (2).的几次方(位宽) / 2 ? (
				(2).的几次方(位宽) - this.数字.内容[1]
			) : (
				this.数字.内容[1]
			)
		];
	}
	释放() {
		this.数字.释放();
	}
	转为字符串() {
		return (
			(
				(是否为负数及其十进制负幂数, 数字) => (
					是否为负数及其十进制负幂数[0] ? (
						`-${数字}e-${是否为负数及其十进制负幂数[1]}`
					) : (
						`${数字}e-${是否为负数及其十进制负幂数[1]}`
					)
				)
			)(
				this.是否为负数并取其十进制负幂数(),
				this.数字.内容[0]
			)
		);
	}
	加(加数) {
		/*
		let 加数1是否为负数及其十进制负幂数=this.是否为负数及其十进制负幂数();
		let 加数2是否为负数及其十进制负幂数=加数.是否为负数及其十进制负幂数();
		*/
		this.以数赋予(
			this.转为数() +
			加数.转为数()
		);
		加数.释放();
		return this;
	}
	减(减数) {
		this.以数赋予(
			this.转为数() -
			减数.转为数()
		);
		减数.释放();
		return this;
	}
	乘(乘数) {
		this.以数赋予(
			this.转为数() *
			乘数.转为数()
		);
		乘数.释放();
		return this;
	}
	除以(除数) {
		this.以数赋予(
			this.转为数() /
			除数.转为数()
		);
		除数.释放();
		return this;
	}
}

class 大数字 {
	constructor(数字字符串) {
		/*
		数	类型
		8	整数
		7.5	小数
		.5	省略整数部的小数
		*2/3分数*/
		let 整数部分 = 未定义;
		let 小数部分 = 未定义;
		let 复数部分 = 未定义;
		let 正负部分 = 未定义;
		this.数字 = 未定义;
		if (数字字符串.的第几个字(0) === "-") {
			正负部分 = 假;
			数字字符串 = 数字字符串.子字符串(1);
		} else {
			正负部分 = 真;
		}
		if (数字字符串.的第几个字(0) !== "*") {
			let 临时数字处理结果 = 数字字符串.分割(".");
			if (临时数字处理结果.的长度() === 1) {
				//是整数
				整数部分 = 临时数字处理结果[0];
			} else {
				if (临时数字处理结果[0] === "") {
					临时数字处理结果[0] = "0";
				}
				整数部分 = 临时数字处理结果[0];
				小数部分 = 临时数字处理结果[1];
				/*(
					(
						typeof  临时数字处理结果[1] ===类型的中文.数字
					)? 临时数字处理结果[1]:"0"
				) */
				复数部分 = "";
			}
		} else {
			console.log(数字字符串)
		}
		if (高精度演算) {
			//打印(整数部分, 小数部分, 复数部分, 正负部分)
			this.数字 = [
				(
					(
						typeof 整数部分 === 类型的中文.字符串 && 整数部分
					) ? 整数部分 : "0"
				).分割(""),
				(
					(
						typeof 小数部分 === 类型的中文.字符串 && 小数部分
					) ? 小数部分 : "0"
				).分割(""),
				(
					(
						typeof 复数部分 === 类型的中文.字符串 && 复数部分
					) ? 复数部分 : "0"
				).分割(""),
				正负部分
			];
		} else {
			//debugger
			this.数字 = (
				(
					(
						typeof 整数部分 === 类型的中文.字符串 ? 整数部分.转为数(
							真
						) : 0
					) + (
						typeof 小数部分 === 类型的中文.字符串 ? (
							小数部分.转为数(真) / (
								(10).的几次方(小数部分.的长度())
							)
						) : 0
					)
				) * (正负部分 ? 1 : -1)
			);
			打印(this.数字);
		}
	}
	转为字符串() {
		if (高精度演算) {
			let 结果 = this.数字[0].加入("");
			if (!(this.数字[1].的长度() === 1 && this.数字[1][0] === "0")) {
				结果 = `${结果}.${this.数字[1].加入("")}`;
			}
			if (!this.数字[3]) {
				结果 = `-${结果}`;
			}
			if (this.数字[2][0] !== "0") {
				return `${this.数字[2].加入("")}i+${结果}`;
			} else {
				return 结果;
			}
		} else {
			return this.数字.转为字符串();
		}
	}
	toString() {
		this.转为字符串();
	}
	非高精度演算的情况下取出数值(对象) {
		if (typeof 对象 === 类型的中文.数字) {
			return 对象;
		} else {
			try {
				return 对象.数字;
			} catch (错误) {
				打印(错误);
			}
		}
	}
	加(加数) {
		if (高精度演算) {
			//打印(this.转为字符串(), "+", 加数.转为字符串());
			let 临时数位〇 = 0;
			let 临时数位一 = 0;
			let 本数位数, 加数位数, 最长位数, 小数结果;
			let 结果 = ~~this.数字[0][0] + ~~加数.数字[0][0];
			for (
				let i = (
					(
						(本数位数 = this.数字[1].的长度())
						.小于(加数位数 = 加数.数字[1].的长度())
					) ?
					/*加数更长的话*/
					(最长位数 = 加数位数) + 返回零(
						(小数结果 = new Array(最长位数))
					) :
					/*本数更长的话*/
					(最长位数 = 加数位数) + 返回零(
						(小数结果 = new Array(最长位数))
					)
				) - 1; i >= 0; i--
			) {
				临时数位〇 = (i < 本数位数 ? this.数字[1][i] : 0);
				临时数位一 = (i < 加数位数 ? 加数.数字[1][i] : 0);
				小数结果[i] = (
					小数结果[i] ?
					~~临时数位〇 + ~~临时数位一 + 1 :
					~~临时数位〇 + ~~临时数位一
				);
				if (小数结果[i] >= 10) {
					if (i <= 0) {
						结果++;
					} else {
						小数结果[i - 1] = 1;
					}
					小数结果[i] -= 10;
				}
				//打印(i, 临时数位〇, 临时数位一, 小数结果);
			}
			this.数字[0] = 结果.转为字符串().分割("");
			this.数字[1] = 小数结果;
			return this;
		} else {
			this.数字 += this.非高精度演算的情况下取出数值(加数);
			return this;
		}
	}
	减(被减数) {
		if (高精度演算) {
			打印(this.转为字符串(), "+", 被减数.转为字符串());
			let 临时数位〇 = 0;
			let 临时数位一 = 0;
			let 减数位数, 被减数位数, 最长位数, 小数结果;
			let 结果 = ~~this.数字[0][0] + ~~被减数.数字[0][0];
			for (
				let i = (
					(
						(减数位数 = this.数字[1].的长度())
						.小于(被减数位数 = 被减数.数字[1].的长度())
					) ?
					/*被减数更长的话*/
					(最长位数 = 被减数位数) + 返回零(
						(小数结果 = new Array(最长位数))
					) :
					/*减数更长的话*/
					(最长位数 = 被减数位数) + 返回零(
						(小数结果 = new Array(最长位数))
					)
				) - 1; i >= 0; i--
			) {
				临时数位〇 = (i < 减数位数 ? this.数字[1][i] : 0);
				临时数位一 = (i < 被减数位数 ? 被减数.数字[1][i] : 0);
				小数结果[i] = (
					小数结果[i] ?
					~~临时数位〇 + ~~临时数位一 + 1 :
					~~临时数位〇 + ~~临时数位一
				);
				if (小数结果[i] >= 10) {
					if (i <= 0) {
						结果++;
					} else {
						小数结果[i - 1] = 1;
					}
					小数结果[i] -= 10;
				}
				//打印(i, 临时数位〇, 临时数位一, 小数结果);
			}
			this.数字[0] = 结果.转为字符串().分割("");
			this.数字[1] = 小数结果;
			return this;
		} else {
			this.数字 += this.非高精度演算的情况下取出数值(被减数);
			return this;
		}
	}
	乘(乘数) {
		return 乘数;
	}
	除以(被除数) {
		return 被除数;
	}
}
const 打印栈 = (
	(栈) => (
		`
			<table border="1">
				<tr>
					<td>
					${
						(栈.栈?栈.栈:栈).遍历(
							对象=>对象.类型
						).加入("</td><td>")
					}
					</td>
				</tr>
				<tr>
					<td>
					${
						(栈.栈?栈.栈:栈).遍历(
							对象=>{
								switch(对象.类型){
									case "延迟":
										return(
											打印栈(
												对象
												.内容
											)
										);
									case "字典":
										return(
							`
								<table>
									<tr>
										<td>
											${
												对象的键们(
													对象.内容
												)
												.加入("</td><td>")
											}
										</td>
									</tr>
									<tr>
										<td>
											${
												(
													(对象, 键名)=>键名.遍历(
														键名=>打印栈(
															[
																对象[键名]
															]
														)
													)
												)(
													对象.内容,
													对象的键们(
														对象.内容
													)
												)
												.加入("</td><td>")
											}
										</td>
									</tr>
								</table>
							`
										);
									default:
										return 对象
										.内容;
								}
							}
						).加入("</td><td>")
					}
					</td>
				</tr>
			</table>
		`
	)
)

function 测试代码() {
	//打印(new 数字(".75").加(new 数字("2.25")).转为数());
	/*打印(new 数字(".2").加(new 数字(".1")).转为数());*/
	/*打印(new 数字("-2").转为字符串());
	打印(new 数字("-2.666").转为字符串());
	打印(new 数字("-.3").转为字符串());
	打印(new 数字(".128").转为字符串());
	打印(new 数字("2.666").转为字符串());*/
	//0.3
	/*(
		i < ((
			this.结束地址 - this.起始地址 + 1) / (位宽 * 2) * 字节比特数)
	)*/
	/* v1 = new 内存对象();
	v1.分配(200);
	v = new 内存对象();
	v.分配(200);
	v.内容[1] = 1000;
	v1.内容[2] = 2;
	打印("v,", v);
	打印("v1,", v1);
	v.释放();
	打印("ncb,", 已使用内存.内存表内容);
	v2 = new 内存对象();
	//debugger
	v2.分配(200);
	打印("v2", v2);
	打印("ncb,", 已使用内存.内存表内容); */
}